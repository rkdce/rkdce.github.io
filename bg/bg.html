<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>U²-Net Background Remover</title>
<script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js"></script>
<style>
  body { font-family: Arial, sans-serif; padding: 20px; }
  canvas { border: 1px solid #ccc; margin-top: 10px; max-width: 100%; }
</style>
</head>
<body>

<h1>U²-Net Background Remover</h1>

<input type="file" id="imageUpload" accept="image/*"><br><br>
<label>Background color: <input type="color" id="bgColor" value="#ffffff"></label><br><br>
<label>Name: <input type="text" id="nameText"></label><br><br>
<label>Date: <input type="text" id="dateText" placeholder="YYYY-MM-DD"></label><br><br>
<label>Font size: <input type="number" id="fontSize" value="20" min="10" max="100"> px</label><br><br>

<button id="processBtn">Remove Background</button><br><br>
<canvas id="resultCanvas"></canvas><br><br>
<a id="downloadLink" href="#" download="output.png">Download Result</a>

<script>
const MODEL_URL = "https://github.com/danielgatis/rembg/releases/download/v0.0.0/u2net.onnx";

async function loadImage(file) {
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.onload = () => resolve(img);
    img.onerror = reject;
    img.src = URL.createObjectURL(file);
  });
}

async function imageToTensor(img) {
  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d');
  canvas.width = 320;
  canvas.height = 320;
  ctx.drawImage(img, 0, 0, 320, 320);
  const imgData = ctx.getImageData(0, 0, 320, 320);
  const data = Float32Array.from(imgData.data).filter((_, i) => i % 4 !== 3);
  const transposed = new Float32Array(3 * 320 * 320);
  for (let i = 0; i < 320 * 320; i++) {
    transposed[i] = data[i * 3] / 255;
    transposed[i + 320 * 320] = data[i * 3 + 1] / 255;
    transposed[i + 2 * 320 * 320] = data[i * 3 + 2] / 255;
  }
  return new ort.Tensor('float32', transposed, [1, 3, 320, 320]);
}

async function runModel(img) {
  const session = await ort.InferenceSession.create(MODEL_URL, { executionProviders: ['wasm'] });
  const tensor = await imageToTensor(img);
  const results = await session.run({ 'input': tensor });
  const mask = results['output'];
  return mask.data;
}

function applyMask(originalImg, mask, bgColor, name, date, fontSize) {
  const canvas = document.getElementById('resultCanvas');
  canvas.width = originalImg.width;
  canvas.height = originalImg.height;
  const ctx = canvas.getContext('2d');

  ctx.fillStyle = bgColor;
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  const imgCanvas = document.createElement('canvas');
  const imgCtx = imgCanvas.getContext('2d');
  imgCanvas.width = canvas.width;
  imgCanvas.height = canvas.height;
  imgCtx.drawImage(originalImg, 0, 0);
  const imgData = imgCtx.getImageData(0, 0, canvas.width, canvas.height);

  for (let i = 0; i < mask.length; i++) {
    const y = Math.floor(i / 320);
    const x = i % 320;
    const alpha = mask[i] * 255;
    const scaleX = Math.floor((x / 320) * canvas.width);
    const scaleY = Math.floor((y / 320) * canvas.height);
    const idx = (scaleY * canvas.width + scaleX) * 4 + 3;
    imgData.data[idx] = alpha;
  }

  imgCtx.putImageData(imgData, 0, 0);
  ctx.drawImage(imgCanvas, 0, 0);

  ctx.font = `${fontSize}px Arial`;
  ctx.fillStyle = "black";
  ctx.fillText(name, 10, canvas.height - 40);
  ctx.fillText(date, 10, canvas.height - 10);
}

document.getElementById('processBtn').addEventListener('click', async () => {
  const file = document.getElementById('imageUpload').files[0];
  if (!file) return alert("Please upload an image first!");
  const name = document.getElementById('nameText').value;
  const date = document.getElementById('dateText').value;
  const fontSize = document.getElementById('fontSize').value;
  const bgColor = document.getElementById('bgColor').value;

  const img = await loadImage(file);
  const mask = await runModel(img);
  applyMask(img, mask, bgColor, name, date, fontSize);

  document.getElementById('downloadLink').href = document.getElementById('resultCanvas').toDataURL();
});
</script>
</body>
</html>
